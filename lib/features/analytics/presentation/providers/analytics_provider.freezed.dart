// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'analytics_provider.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AnalyticsState {
  AnalyticsPeriod get period => throw _privateConstructorUsedError;
  DateTime get startDate => throw _privateConstructorUsedError;
  DateTime get endDate => throw _privateConstructorUsedError;
  double get totalTurnover => throw _privateConstructorUsedError;
  int get successfulDealsCount => throw _privateConstructorUsedError;
  double get averageCheck => throw _privateConstructorUsedError;
  double get minDeal => throw _privateConstructorUsedError;
  double get maxDeal => throw _privateConstructorUsedError;
  List<Deal> get deals => throw _privateConstructorUsedError;
  bool get isLoading => throw _privateConstructorUsedError;
  double get targetTurnover => throw _privateConstructorUsedError;
  double get totalProfit => throw _privateConstructorUsedError;
  double get averageMargin => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AnalyticsStateCopyWith<AnalyticsState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnalyticsStateCopyWith<$Res> {
  factory $AnalyticsStateCopyWith(
          AnalyticsState value, $Res Function(AnalyticsState) then) =
      _$AnalyticsStateCopyWithImpl<$Res, AnalyticsState>;
  @useResult
  $Res call(
      {AnalyticsPeriod period,
      DateTime startDate,
      DateTime endDate,
      double totalTurnover,
      int successfulDealsCount,
      double averageCheck,
      double minDeal,
      double maxDeal,
      List<Deal> deals,
      bool isLoading,
      double targetTurnover,
      double totalProfit,
      double averageMargin});
}

/// @nodoc
class _$AnalyticsStateCopyWithImpl<$Res, $Val extends AnalyticsState>
    implements $AnalyticsStateCopyWith<$Res> {
  _$AnalyticsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? period = null,
    Object? startDate = null,
    Object? endDate = null,
    Object? totalTurnover = null,
    Object? successfulDealsCount = null,
    Object? averageCheck = null,
    Object? minDeal = null,
    Object? maxDeal = null,
    Object? deals = null,
    Object? isLoading = null,
    Object? targetTurnover = null,
    Object? totalProfit = null,
    Object? averageMargin = null,
  }) {
    return _then(_value.copyWith(
      period: null == period
          ? _value.period
          : period // ignore: cast_nullable_to_non_nullable
              as AnalyticsPeriod,
      startDate: null == startDate
          ? _value.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      endDate: null == endDate
          ? _value.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      totalTurnover: null == totalTurnover
          ? _value.totalTurnover
          : totalTurnover // ignore: cast_nullable_to_non_nullable
              as double,
      successfulDealsCount: null == successfulDealsCount
          ? _value.successfulDealsCount
          : successfulDealsCount // ignore: cast_nullable_to_non_nullable
              as int,
      averageCheck: null == averageCheck
          ? _value.averageCheck
          : averageCheck // ignore: cast_nullable_to_non_nullable
              as double,
      minDeal: null == minDeal
          ? _value.minDeal
          : minDeal // ignore: cast_nullable_to_non_nullable
              as double,
      maxDeal: null == maxDeal
          ? _value.maxDeal
          : maxDeal // ignore: cast_nullable_to_non_nullable
              as double,
      deals: null == deals
          ? _value.deals
          : deals // ignore: cast_nullable_to_non_nullable
              as List<Deal>,
      isLoading: null == isLoading
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      targetTurnover: null == targetTurnover
          ? _value.targetTurnover
          : targetTurnover // ignore: cast_nullable_to_non_nullable
              as double,
      totalProfit: null == totalProfit
          ? _value.totalProfit
          : totalProfit // ignore: cast_nullable_to_non_nullable
              as double,
      averageMargin: null == averageMargin
          ? _value.averageMargin
          : averageMargin // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AnalyticsStateImplCopyWith<$Res>
    implements $AnalyticsStateCopyWith<$Res> {
  factory _$$AnalyticsStateImplCopyWith(_$AnalyticsStateImpl value,
          $Res Function(_$AnalyticsStateImpl) then) =
      __$$AnalyticsStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {AnalyticsPeriod period,
      DateTime startDate,
      DateTime endDate,
      double totalTurnover,
      int successfulDealsCount,
      double averageCheck,
      double minDeal,
      double maxDeal,
      List<Deal> deals,
      bool isLoading,
      double targetTurnover,
      double totalProfit,
      double averageMargin});
}

/// @nodoc
class __$$AnalyticsStateImplCopyWithImpl<$Res>
    extends _$AnalyticsStateCopyWithImpl<$Res, _$AnalyticsStateImpl>
    implements _$$AnalyticsStateImplCopyWith<$Res> {
  __$$AnalyticsStateImplCopyWithImpl(
      _$AnalyticsStateImpl _value, $Res Function(_$AnalyticsStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? period = null,
    Object? startDate = null,
    Object? endDate = null,
    Object? totalTurnover = null,
    Object? successfulDealsCount = null,
    Object? averageCheck = null,
    Object? minDeal = null,
    Object? maxDeal = null,
    Object? deals = null,
    Object? isLoading = null,
    Object? targetTurnover = null,
    Object? totalProfit = null,
    Object? averageMargin = null,
  }) {
    return _then(_$AnalyticsStateImpl(
      period: null == period
          ? _value.period
          : period // ignore: cast_nullable_to_non_nullable
              as AnalyticsPeriod,
      startDate: null == startDate
          ? _value.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      endDate: null == endDate
          ? _value.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      totalTurnover: null == totalTurnover
          ? _value.totalTurnover
          : totalTurnover // ignore: cast_nullable_to_non_nullable
              as double,
      successfulDealsCount: null == successfulDealsCount
          ? _value.successfulDealsCount
          : successfulDealsCount // ignore: cast_nullable_to_non_nullable
              as int,
      averageCheck: null == averageCheck
          ? _value.averageCheck
          : averageCheck // ignore: cast_nullable_to_non_nullable
              as double,
      minDeal: null == minDeal
          ? _value.minDeal
          : minDeal // ignore: cast_nullable_to_non_nullable
              as double,
      maxDeal: null == maxDeal
          ? _value.maxDeal
          : maxDeal // ignore: cast_nullable_to_non_nullable
              as double,
      deals: null == deals
          ? _value._deals
          : deals // ignore: cast_nullable_to_non_nullable
              as List<Deal>,
      isLoading: null == isLoading
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      targetTurnover: null == targetTurnover
          ? _value.targetTurnover
          : targetTurnover // ignore: cast_nullable_to_non_nullable
              as double,
      totalProfit: null == totalProfit
          ? _value.totalProfit
          : totalProfit // ignore: cast_nullable_to_non_nullable
              as double,
      averageMargin: null == averageMargin
          ? _value.averageMargin
          : averageMargin // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$AnalyticsStateImpl implements _AnalyticsState {
  const _$AnalyticsStateImpl(
      {required this.period,
      required this.startDate,
      required this.endDate,
      required this.totalTurnover,
      required this.successfulDealsCount,
      required this.averageCheck,
      required this.minDeal,
      required this.maxDeal,
      required final List<Deal> deals,
      required this.isLoading,
      required this.targetTurnover,
      required this.totalProfit,
      required this.averageMargin})
      : _deals = deals;

  @override
  final AnalyticsPeriod period;
  @override
  final DateTime startDate;
  @override
  final DateTime endDate;
  @override
  final double totalTurnover;
  @override
  final int successfulDealsCount;
  @override
  final double averageCheck;
  @override
  final double minDeal;
  @override
  final double maxDeal;
  final List<Deal> _deals;
  @override
  List<Deal> get deals {
    if (_deals is EqualUnmodifiableListView) return _deals;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_deals);
  }

  @override
  final bool isLoading;
  @override
  final double targetTurnover;
  @override
  final double totalProfit;
  @override
  final double averageMargin;

  @override
  String toString() {
    return 'AnalyticsState(period: $period, startDate: $startDate, endDate: $endDate, totalTurnover: $totalTurnover, successfulDealsCount: $successfulDealsCount, averageCheck: $averageCheck, minDeal: $minDeal, maxDeal: $maxDeal, deals: $deals, isLoading: $isLoading, targetTurnover: $targetTurnover, totalProfit: $totalProfit, averageMargin: $averageMargin)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalyticsStateImpl &&
            (identical(other.period, period) || other.period == period) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.endDate, endDate) || other.endDate == endDate) &&
            (identical(other.totalTurnover, totalTurnover) ||
                other.totalTurnover == totalTurnover) &&
            (identical(other.successfulDealsCount, successfulDealsCount) ||
                other.successfulDealsCount == successfulDealsCount) &&
            (identical(other.averageCheck, averageCheck) ||
                other.averageCheck == averageCheck) &&
            (identical(other.minDeal, minDeal) || other.minDeal == minDeal) &&
            (identical(other.maxDeal, maxDeal) || other.maxDeal == maxDeal) &&
            const DeepCollectionEquality().equals(other._deals, _deals) &&
            (identical(other.isLoading, isLoading) ||
                other.isLoading == isLoading) &&
            (identical(other.targetTurnover, targetTurnover) ||
                other.targetTurnover == targetTurnover) &&
            (identical(other.totalProfit, totalProfit) ||
                other.totalProfit == totalProfit) &&
            (identical(other.averageMargin, averageMargin) ||
                other.averageMargin == averageMargin));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      period,
      startDate,
      endDate,
      totalTurnover,
      successfulDealsCount,
      averageCheck,
      minDeal,
      maxDeal,
      const DeepCollectionEquality().hash(_deals),
      isLoading,
      targetTurnover,
      totalProfit,
      averageMargin);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalyticsStateImplCopyWith<_$AnalyticsStateImpl> get copyWith =>
      __$$AnalyticsStateImplCopyWithImpl<_$AnalyticsStateImpl>(
          this, _$identity);
}

abstract class _AnalyticsState implements AnalyticsState {
  const factory _AnalyticsState(
      {required final AnalyticsPeriod period,
      required final DateTime startDate,
      required final DateTime endDate,
      required final double totalTurnover,
      required final int successfulDealsCount,
      required final double averageCheck,
      required final double minDeal,
      required final double maxDeal,
      required final List<Deal> deals,
      required final bool isLoading,
      required final double targetTurnover,
      required final double totalProfit,
      required final double averageMargin}) = _$AnalyticsStateImpl;

  @override
  AnalyticsPeriod get period;
  @override
  DateTime get startDate;
  @override
  DateTime get endDate;
  @override
  double get totalTurnover;
  @override
  int get successfulDealsCount;
  @override
  double get averageCheck;
  @override
  double get minDeal;
  @override
  double get maxDeal;
  @override
  List<Deal> get deals;
  @override
  bool get isLoading;
  @override
  double get targetTurnover;
  @override
  double get totalProfit;
  @override
  double get averageMargin;
  @override
  @JsonKey(ignore: true)
  _$$AnalyticsStateImplCopyWith<_$AnalyticsStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
